\doxysection{CMEPDA-\/\+GLAST/\+Interface.py File Reference}
\hypertarget{Interface_8py}{}\label{Interface_8py}\index{CMEPDA-\/GLAST/Interface.py@{CMEPDA-\/GLAST/Interface.py}}


Interface used to call c++ macros.  


\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{Interface_8py_ac251e2e26217d607fbf604178ea48c92}{Interface.\+Clustering}} (fileinput, fileoutput)
\begin{DoxyCompactList}\small\item\em Docs for clustering This function performs the first abstractin of data by calling the c++ macros \doxylink{CreateTree_8cpp}{Create\+Tree.\+cpp} . \end{DoxyCompactList}\item 
\mbox{\hyperlink{Interface_8py_ab2eda89ccc82925973832210275a7aa0}{Interface.\+Tracking}} (fileinput, fileoutput)
\begin{DoxyCompactList}\small\item\em Docs for Tracking This function performs the second abstractin of data by calling the \doxylink{Retina_8cpp}{Retina.\+cpp} , \doxylink{RectifyTracks_8cpp}{Rectify\+Tracks.\+cpp} and \doxylink{UnifyTree_8cpp_source}{Unify\+Tree.\+cpp} macros. \end{DoxyCompactList}\item 
\mbox{\hyperlink{Interface_8py_a01d16339d60381f45520e5bc1427f1db}{Interface.\+Test\+Reconstruction}} ()
\begin{DoxyCompactList}\small\item\em Docs for testing the tracking algorithm This function starts by calling the c++ macro Monte\+Carlo\+Generazione\+Dati.\+cpp that simulate a data acquisition with only 1 tracks per vision and no noise, the simulated data is fed to the tracking algorithm in the macro \doxylink{Retina_8cpp}{Retina.\+cpp} . \end{DoxyCompactList}\item 
\mbox{\hyperlink{Interface_8py_a0fb5da7971754ec9fc962a11eff21420}{Interface.\+Montecarlo}} (fileinput, fileoutput)
\begin{DoxyCompactList}\small\item\em Docs for doing MC simulation This function call the c++ macro Monte\+Carlo.\+cpp that runs a MC simulation of 3D tracks that goes through the tracker. \end{DoxyCompactList}\item 
\mbox{\hyperlink{Interface_8py_a6c70ecdabc46a3a1f89e4416b325008a}{Interface.\+Results}} (fileinput, fileoutput)
\begin{DoxyCompactList}\small\item\em Docs function that shows results. \end{DoxyCompactList}\item 
\mbox{\hyperlink{Interface_8py_a62de84edea2804b969c8dc2ee5ce6577}{Interface.\+Interface\+\_\+parse}} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Interface used to call c++ macros. 

Several options for data analysis can be chosen. 

Definition in file \mbox{\hyperlink{Interface_8py_source}{Interface.\+py}}.



\doxysubsection{Function Documentation}
\Hypertarget{Interface_8py_ac251e2e26217d607fbf604178ea48c92}\label{Interface_8py_ac251e2e26217d607fbf604178ea48c92} 
\index{Interface.py@{Interface.py}!Clustering@{Clustering}}
\index{Clustering@{Clustering}!Interface.py@{Interface.py}}
\doxysubsubsection{\texorpdfstring{Clustering()}{Clustering()}}
{\footnotesize\ttfamily Interface.\+Clustering (\begin{DoxyParamCaption}\item[{}]{fileinput,  }\item[{}]{fileoutput }\end{DoxyParamCaption})}



Docs for clustering This function performs the first abstractin of data by calling the c++ macros \doxylink{CreateTree_8cpp}{Create\+Tree.\+cpp} . 


\begin{DoxyParams}{Parameters}
{\em fileinput} & \\
\hline
{\em fileoutput} & \\
\hline
\end{DoxyParams}
After abstracting the data, a second macro is called to plot the Cluster Number Distribution, the Cluster Position distribution on the layer X2 and the number of Clusters per event distribution 
\begin{DoxyParams}{Parameters}
{\em fileinput} & Name of the input file with extension, the path is not necessary.\\
\hline
{\em fileoutput} & Name of the outputfile with no extension., the output file is put in the folder Dataroot/\+Cluster\+Abstraction\+Data with the name fileoutput.\+root \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{Interface_8py_source_l00030}{30}} of file \mbox{\hyperlink{Interface_8py_source}{Interface.\+py}}.

\Hypertarget{Interface_8py_a62de84edea2804b969c8dc2ee5ce6577}\label{Interface_8py_a62de84edea2804b969c8dc2ee5ce6577} 
\index{Interface.py@{Interface.py}!Interface\_parse@{Interface\_parse}}
\index{Interface\_parse@{Interface\_parse}!Interface.py@{Interface.py}}
\doxysubsubsection{\texorpdfstring{Interface\_parse()}{Interface\_parse()}}
{\footnotesize\ttfamily Interface.\+Interface\+\_\+parse (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{Interface_8py_source_l00246}{246}} of file \mbox{\hyperlink{Interface_8py_source}{Interface.\+py}}.

\Hypertarget{Interface_8py_a0fb5da7971754ec9fc962a11eff21420}\label{Interface_8py_a0fb5da7971754ec9fc962a11eff21420} 
\index{Interface.py@{Interface.py}!Montecarlo@{Montecarlo}}
\index{Montecarlo@{Montecarlo}!Interface.py@{Interface.py}}
\doxysubsubsection{\texorpdfstring{Montecarlo()}{Montecarlo()}}
{\footnotesize\ttfamily Interface.\+Montecarlo (\begin{DoxyParamCaption}\item[{}]{fileinput,  }\item[{}]{fileoutput }\end{DoxyParamCaption})}



Docs for doing MC simulation This function call the c++ macro Monte\+Carlo.\+cpp that runs a MC simulation of 3D tracks that goes through the tracker. 

The generated numbers are four\+: (x0,y0) point on the plane of the top layer, zenith angle theta and azimuth angle phi. From this four numbers the projections are generated on the vision XZ and YZ, then the hits are generated and if a track satisfy the trigger condition the angles zenith and azimuth are inserted into a histogram


\begin{DoxyParams}{Parameters}
{\em fileinput} & Name of the input file with extension .lif, the path is not necessary. This input is used to keep account of muted strips in the simulation.\\
\hline
{\em fileoutput} & variable used to specify where to save plots and distributions.\\
\hline
\end{DoxyParams}
The MC distributions are saved into the Data/\+MCSimulations folder. 

Definition at line \mbox{\hyperlink{Interface_8py_source_l00193}{193}} of file \mbox{\hyperlink{Interface_8py_source}{Interface.\+py}}.

\Hypertarget{Interface_8py_a6c70ecdabc46a3a1f89e4416b325008a}\label{Interface_8py_a6c70ecdabc46a3a1f89e4416b325008a} 
\index{Interface.py@{Interface.py}!Results@{Results}}
\index{Results@{Results}!Interface.py@{Interface.py}}
\doxysubsubsection{\texorpdfstring{Results()}{Results()}}
{\footnotesize\ttfamily Interface.\+Results (\begin{DoxyParamCaption}\item[{}]{fileinput,  }\item[{}]{fileoutput }\end{DoxyParamCaption})}



Docs function that shows results. 

This function calls the c++ macros Compare\+Distributions.\+cpp and Extract\+Distributions.\+cpp to extract the zenith and azimuth angle distribution from the measured data and compare them with the MC simulation. It is expected that one had already ran the MC simulation before running the results flag. The resuls are then saved as plot in the Data/\+Results\+Images folder.


\begin{DoxyParams}{Parameters}
{\em fileinput} & path to the tracking root file that contains the data.\\
\hline
{\em fileoutput} & path to where the MC simulations are, contains also the initial 2 letters of the names of the files (MC). \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{Interface_8py_source_l00218}{218}} of file \mbox{\hyperlink{Interface_8py_source}{Interface.\+py}}.

\Hypertarget{Interface_8py_a01d16339d60381f45520e5bc1427f1db}\label{Interface_8py_a01d16339d60381f45520e5bc1427f1db} 
\index{Interface.py@{Interface.py}!TestReconstruction@{TestReconstruction}}
\index{TestReconstruction@{TestReconstruction}!Interface.py@{Interface.py}}
\doxysubsubsection{\texorpdfstring{TestReconstruction()}{TestReconstruction()}}
{\footnotesize\ttfamily Interface.\+Test\+Reconstruction (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Docs for testing the tracking algorithm This function starts by calling the c++ macro Monte\+Carlo\+Generazione\+Dati.\+cpp that simulate a data acquisition with only 1 tracks per vision and no noise, the simulated data is fed to the tracking algorithm in the macro \doxylink{Retina_8cpp}{Retina.\+cpp} . 

The generated distribution takes into account only the trigger condition, it is compared with a Kolmog\+Gorov Test with the reconstructed distribution by the tracking algorithm. One would expect a p-\/value of 1 for an optimal reconstruction

The results are saved into the folder Data/\+MCSimulations/\+Testing\+Retina\+Algorithm 

Definition at line \mbox{\hyperlink{Interface_8py_source_l00118}{118}} of file \mbox{\hyperlink{Interface_8py_source}{Interface.\+py}}.

\Hypertarget{Interface_8py_ab2eda89ccc82925973832210275a7aa0}\label{Interface_8py_ab2eda89ccc82925973832210275a7aa0} 
\index{Interface.py@{Interface.py}!Tracking@{Tracking}}
\index{Tracking@{Tracking}!Interface.py@{Interface.py}}
\doxysubsubsection{\texorpdfstring{Tracking()}{Tracking()}}
{\footnotesize\ttfamily Interface.\+Tracking (\begin{DoxyParamCaption}\item[{}]{fileinput,  }\item[{}]{fileoutput }\end{DoxyParamCaption})}



Docs for Tracking This function performs the second abstractin of data by calling the \doxylink{Retina_8cpp}{Retina.\+cpp} , \doxylink{RectifyTracks_8cpp}{Rectify\+Tracks.\+cpp} and \doxylink{UnifyTree_8cpp_source}{Unify\+Tree.\+cpp} macros. 

It subdivides the data into a number of bunches equal to the number of pc cores, then each cores performs data abstraction on different bunches. At the end the Unify\+Tree macro is called and all created tree are merge into a unique tree put into .root file. It is advised to not interact with the pc throughout this process as this may cause slow-\/downs due to deprivation of resources.


\begin{DoxyParams}{Parameters}
{\em fileinput} & Name of the input file with extension, the path is not necessary.\\
\hline
{\em fileoutput} & Name of the outputfile with no extension, the output file is put in the folder Dataroot/\+Tracking\+Abstraction\+Data with the name fileoutput.\+root \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{Interface_8py_source_l00051}{51}} of file \mbox{\hyperlink{Interface_8py_source}{Interface.\+py}}.

