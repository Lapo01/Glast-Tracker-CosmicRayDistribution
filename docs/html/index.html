<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FERMI-GLAST TRACKER PROJECT: Glast Tracker Measurement of Zenith Angle and Azimuth Angle distributions of cosmic rays</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FERMI-GLAST TRACKER PROJECT
   </div>
   <div id="projectbrief">L&#39;obiettivo di questo progetto è la misura della distribuzione angolare zenith ad azimuth dei raggi cosmici a partire dai dati ottenuti da 10 layer del tracker Fermi-GLast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Glast Tracker Measurement of Zenith Angle and Azimuth Angle distributions of cosmic rays </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The goal of this project is to measure the zenith and azimuth angle distribution of cosmic rays using the Fermi-Glast Tracker. <br  />
 <img src="TrackerFoto.jpeg" alt="" width="10%" class="inline" title="“Foto dell’apparato, la direzione “y” è uscente, la direzione x è invece verso la sinistra.”"/>     <img src="TrackerSchema.png" alt="" width="10%" class="inline" title="“Disposizione dei vari layer del tracker”"/>     <br  />
 In these photos the tracker is portrayed and a faithful succession(not to scale!) along the z axis of the layers is also portrayed. The y-direction is exiting from the sheet, the x-direction is on the left.</p>
<h1><a class="anchor" id="dependencies"></a>
Dependencies</h1>
<p>TESTED ON:</p><ul>
<li>Fedora 40</li>
<li>Linux Mint</li>
<li>NOT TESTED BUT MIGHT WORK ON: MacOS</li>
</ul>
<p>DEPENDENCIES: <br  />
 The code is made up of c++ libraries and macros called by an interface in python, root Cern libraries are used.<br  />
 ROOT CERN VERSION &gt;= 6.30.06 <br  />
 The used root version MUST BE &gt;= 6.30.06 , this is due to a critical code breaking bug in the earlier versions: the Fit method from the TH1F class inherited from the TF1 class has a memory leak that leads to the slowing down of the code and ultimately leads to a crash of the PC. <br  />
</p>
<ul>
<li>to install root on Fedora 40 run in terminal: <br  />
 $ sudo dnf install root root-minuit2 root-cli python36-root root-core root-cling <br  />
 Package : <a href="https://packages.fedoraproject.org/pkgs/root/">https://packages.fedoraproject.org/pkgs/root/</a> <br  />
</li>
<li>to install root on debian based os (Ubuntu, Linux) check site: <a href="https://root.cern/install/">https://root.cern/install/</a><br  />
</li>
</ul>
<p>PYTHON DEPENDENCIES: pyroot , loguru <br  />
</p><ul>
<li>on Fedora 40 run in terminal : <br  />
 $ pip install loguru</li>
<li>on Linux run in terminal : <br  />
 $ pip install loguru pyroot</li>
</ul>
<h1><a class="anchor" id="setup_sec"></a>
Setup</h1>
<p>To setup the package, firstly run in the Core folder:<br  />
 $ cmake ..<br  />
 Then run <br  />
 $ make -jN<br  />
 where N is the number of cores your PC has, one can alternatively just run on one core and do:<br  />
 $ make<br  />
</p>
<h1><a class="anchor" id="intro_sec"></a>
Introduction and brief resume of the project</h1>
<p>The aim of this project is to measure the zenith and azimuth angular distribution of Cosmic Rays using 10 layers of the Fermi-Glast Tracker, each layer contains 1536 strips that are ideally parallel to each other. <br  />
 The layers are subdivided into two main groups XN and YN each composed of 5 layers, those that have strips parallel to a “x” direction and those who have strips parallel to a “y” direction that is perpendicular to the “x” direction. The used tracker returns info on the projection of the cosmic rays, an acquisition is triggered if for each of the vision XZ and YZ the following condition is satisfied:</p><ul>
<li>&gt;= 3 CONSECUTIVE hits It may happen that some of the events do not satisfy this trigger condition due to the premature fall below threshold of the signal generated by the strips as there is a minimum delay of o(100 ns) from the request to start an acquisition and the data taking. In fact, those events amount to about 8%. </li>
</ul>
<h2><a class="anchor" id="first_ab"></a>
First Data Abstraction Phase: Clustering</h2>
<p>A first abstraction of the data is made from hits to cluster by calling the macro <a class="el" href="da/db5/CreateTree_8cpp.html">CreateTree.cpp</a>. A cluster is defined as a series of consecutive strips. <br  />
 A tree is filled with instances of the class <a class="el" href="d1/dc8/classEvento.html">Evento</a>, this object contains info on the hits, their respective layers; info on the position, dimension, initial strip of the clusters and a vector of flags. <br  />
 The most important flag to account of is the first: this flag is set to False if there are in the event clusters adjacent to dead/muted/inefficient strips (strips that have not been activated) . The events that do not satisfy the flag amounts to about 21 %, those are kept but not used in further abstraction of the data.</p>
<h2><a class="anchor" id="second_ab"></a>
Second Data Abstraction Phase: Tracking</h2>
<p>The second abstraction of the phase corresponds to tracking, a track is defined as &gt;= 3 up to 5 clusters (max 1 per layer) for which a linear fit returns a chisquare that is below a 0.95 p-value cut made from the nominal distribution of the chisquare at N dof. The actual studied object are the projections of the tracks rather than the tracks itself. <br  />
 Potential projections of the tracks are identified using a tracking algorithm inspired to the Retina tracking algorithm, which checks for each layer of each vision clusters that are close by 0.5 cm from a straight line with value (m, q); the closest clusters is chosen. This is run on each cell a phase space of (m,q). The obtained info on the clusters and on the linear fit is inserted for each projection on instances of the object <a class="el" href="d9/d18/classTrack.html">Track</a>, all of those instances are then inserted into instances of the object <a class="el" href="d2/da4/classEventoTrack.html">EventoTrack</a> and a root tree object is filled and inserted into a root file. The Object <a class="el" href="d9/d18/classTrack.html">Track</a> contains overloaded operator for &gt; and ==, a <a class="el" href="d9/d18/classTrack.html">Track</a> is “greater” than another if it contains more clusters, a <a class="el" href="d9/d18/classTrack.html">Track</a> is “equal” to another if it contains more than 1 cluster in common. Those operators have been inserted to account for the fact that the tracking algorithm after identifying a track does not remove the points from the events, and so between adjacent phase space cells there may be identified projections that are actually the same one. It has been decided to not remove the points as that may actually introduce dangerous biases. <br  />
 After performing identification of potential projections, systematic error due to relative shifts in X, Y , Z and rotations between the Layers are corrected, in this project the macros to calculate this corrections are not include. However, here we report the way those corrections have been calculated.<br  />
 Firstly, the population of events selected is the one that satisfy the second Flag of the object <a class="el" href="d1/dc8/classEvento.html">Evento</a>, which is a maximum of 1 cluster per layer. We assume that those contains projections of the tracks. <br  />
 After chosing this populations, the shifts are calculated in the following order:</p><ul>
<li>Shifts on X, Y: those are calculated by keeping the layers X0, X3 and Y1 , Y4 fixed, the events chosen from the original population are those that have vertical projection on both vision in order to decorrelate the calculation from the shifts along the Z direction. In those events if there are clusters in the fixed layers a straight line that passes between those is drawn, the distance in along the X or Y directions between the clusters are calculated from this line for each other layer: after filling an histogram with the the distances along the direction X or Y for each layer the mean is used as shift correction.</li>
<li>Shifts on Z: after performing the shift correction on the X, Y directions, all the events from the population with the second Flag activated are taken. Like in the calculation for the shifts in X, Y the layers X0, X3, Y1 and Y4 are fixed in position, if in an event clusters are in those fixed layers then a straight line is drawn and for each layer XN and YN the distances along the direction Z between the clusters and the drawn line are then inserted in a histogram for each layer, the means are taken as shifts on the Z directions. -Relative rotations on Planes: This correction is possible only in case there is 1 projection per vision as in this case one can affirm that the projections belong to the same 3D track. This correction is iterative. After performing the shift corrections along the X, Y, Z directions, for each layer fits are made by excluding the cluster in the layer, then residuals along the distance X or Y depending on the layer are correlated to correspondent position on the other vision which can be calculated since there are no ambiguities in the 3D reconstruction. A linear fit is made and then correction are fed on the position of the clusters at each iteration, ultimately the corrections is stopped when the angular coefficient of the fitted line in the residuals vs hit position along the strip plot is close enough to 0. <br  />
</li>
</ul>
<p>After all the corrections, errors on each layers are set to the standard deviation of the residuals after performing fits excluding clusters from the layer , and a cut is made at a nominal p-value of 0.95. <br  />
</p><ul>
<li>After this cut, the zenith and azimuth angle can be calculated and the tracking phase abstraction is concluded. </li>
</ul>
<h2><a class="anchor" id="first_sec_first_sub_sec"></a>
Structure of the package</h2>
<p>The package is structured in the following way: An interface is written in python language and firstly load using a rootlogon.C file the shared utils libraries written in C++. The <a class="el" href="d9/d60/Interface_8py.html" title="Interface used to call c++ macros.">Interface.py</a> can be run with multiple options, the usual workflow is the following:</p><ul>
<li>$ python <a class="el" href="d9/d60/Interface_8py.html" title="Interface used to call c++ macros.">Interface.py</a> -i infile.lif -o outfileCluster -Clustering <br  />
 Performs the first abstraction of data from hits to clusters<br  />
</li>
<li>$ python <a class="el" href="d9/d60/Interface_8py.html" title="Interface used to call c++ macros.">Interface.py</a> -i infile.lif -o outfileMC -MCDist <br  />
 Generates MC expected measured distributions for the zenith and azimuth angles simulating dead strips and mean efficiency of the layers. The dimension of the clusters, smearing of residuals are not taken into account and other refinements are not taken into account.<br  />
</li>
<li>$ python <a class="el" href="d9/d60/Interface_8py.html" title="Interface used to call c++ macros.">Interface.py</a> -i outfileCluster.root -o outfleTracks -Tracking<br  />
 Performs the second abstraction of data from clusters to tracks.</li>
<li>$ python <a class="el" href="d9/d60/Interface_8py.html" title="Interface used to call c++ macros.">Interface.py</a> -i outfileTracks.root -Results<br  />
 Display the results and returns the p-value from a kolmogorov tests between <br  />
 measured distributions and Montecarlo simulated ones. <br  />
 Other options are<ul>
<li>$ python <a class="el" href="d9/d60/Interface_8py.html" title="Interface used to call c++ macros.">Interface.py</a> -TestReconstruction <br  />
 Tests the reconstruction made by the tracking algorithm by feeding it a generated distribution of events that have one projection per vision XZ and YZ. The number of identified projection is reported and compared with the expected one, the efficiency of the algorithm is calculated dividing the number of events that have 1 reconstructed track per layer by the total number of generated events. After this first steps a kolmogorov tests is taken and the zenith and azimuth angle reconstructed distributions are compared to the generated ones, a p-value is returned for both comparisons. <br  />
</li>
<li>$ python <a class="el" href="d9/d60/Interface_8py.html" title="Interface used to call c++ macros.">Interface.py</a> -TrackSee N M <br  />
 Displays an event with N projections on the XZ vision and M projections on the YZ vision.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="sec_otherstuff"></a>
Other Improvements</h1>
<p>Multitracking analysis has not been included in this project, however one may easily do multitracking 2D analysis just by studying the distribution of angles between tracks, comparison can be made between the distributions of angles between projections in the same events and angles between projections from different events (to take away the correlation). <br  />
 One could also study the vertex distributions in the projection planes. <br  />
 Also one may introduce heavy materials such as lead to study muon decays, however this is much more ambitious than the previous ideas.<br  />
 </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
